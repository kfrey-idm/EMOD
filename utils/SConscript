# This Python script, SConscript, invoked by the SConscript in the upper directory,
#
# 1. builds utils static library

import os
from subprocess import Popen, PIPE
import shutil
import getpass

Import("env")

if os.sys.platform == 'win32':
    ppf = '/D' # Visual Studio preprocessor define flag
    edq = '\\"' # Need to escape double quote on Windows
    esq = ''
    username = getpass.getuser()
else:
    ppf = '-D' # GCC preprocessor define flag
    edq = '"'
    esq = '\'' # Linux uses an extra single quote
    username = os.environ['USER']

root = Dir('#').abspath
version_info_path = os.path.join(root,"utils/version_info.h")
version_tmpl_path = os.path.join(root,"utils/version_info.tmpl")
if os.path.exists(version_info_path):
    os.remove(version_info_path)
shutil.copy(version_tmpl_path, version_info_path )

# Extract major and minor versions from version info file
with open(version_info_path) as fid01:
    def_lines = [lval.strip().split() for lval in fid01.readlines() if lval.startswith('#define')]

for lval in def_lines:
    if (lval[1] == 'MAJOR_VERSION'):
        ver_maj = lval[2]
    if (lval[1] == 'MINOR_VERSION'):
        ver_min = lval[2]

ver_tag = "v{:s}.{:s}".format(ver_maj, ver_min)

# commit/branch info
git_rev_handle = Popen(["git","rev-list","{:s}..HEAD".format(ver_tag),"--count"], stdout=PIPE, stderr=PIPE)
rev = git_rev_handle.stdout.read().decode().strip().strip( '"\'' ).replace(" ","_")
git_err = git_rev_handle.stderr.read().decode()
if git_err:
    # Raising an error breaks the Jenkins build; should be an error once off of Jenkins
    # raise Exception(git_err)
    rev = '0'

git_branch_handle = Popen( "git rev-parse --abbrev-ref HEAD".split(), stdout=PIPE )
branch = git_branch_handle.stdout.read().decode().strip().strip( '"\'' ).replace(" ","_")
if branch == "":
    branch = "unknownbranch"

git_sha_handle = Popen( "git log --pretty=format:'%h' -n 1".split(), stdout=PIPE )
sha1 = git_sha_handle.stdout.read().decode().strip().strip( '"\'' ).replace(" ","_")
if sha1 == "":
    sha1 = "unknownsha1"
sha1 = '(' + sha1 + ')'

git_date_handle = Popen( "git log -1 --pretty=%ai".split(), stdout=PIPE )
git_date = git_date_handle.stdout.read().decode().strip().strip( '"\'' ).replace(' ','_')
if git_date == "":
    git_date = "unknown_date_time"


print( branch + sha1 )

REV_STR = ppf + 'REVISION_NUMBER=' + esq + rev + esq
env.Append( CCFLAGS=[ REV_STR ] )

BRH_STR = ppf + 'SCCS_BRANCH='+ esq + edq + branch + sha1 + edq + esq
env.Append( CCFLAGS=[ BRH_STR ] )

GIT_STR = ppf + 'SCCS_DATE=' + esq + edq + git_date + edq + esq
env.Append( CCFLAGS=[ GIT_STR ] )

USR_STR = ppf + 'BUILDER_NAME='+ esq + edq + username + edq + esq
env.Append( CCFLAGS=[ USR_STR ] )


utilsSrcFiles = [
    "BaseProperties.cpp",
    "BinaryArchiveReader.cpp",
    "BinaryArchiveWriter.cpp",
    "ConfigParams.cpp",
    "Configuration.cpp",
    "Configure.cpp",
    "Coredump.cpp",
    "DistributionBase.cpp",
    "DistributionsConfigurable.cpp",
    "DistributionFactory.cpp",
    "Distributions.cpp",
    "Environment.cpp",
    "EventTrigger.cpp",
    "EventTriggerNode.cpp",
    "EventTriggerCoordinator.cpp",
    "Exceptions.cpp",
    "FileSystem.cpp",
    "IArchive.cpp",
    "IdmDateTime.cpp",
    "IdmMpi.cpp",
    "InterpolatedValueMap.cpp",
    "InstructionSetInfo.cpp",
    "ISerializable.cpp",
    "ISupports.cpp",
    "JsonFullReader.cpp",
    "JsonFullWriter.cpp",
    "JsonObject.cpp",
    "JsonObjectDemog.cpp",
    "JsonRawReader.cpp",
    "JsonRawWriter.cpp",
    "Log.cpp",
    "MathFunctions.cpp",
    "numpy-files.cpp",
    "Memory.cpp",
    "NodeProperties.cpp",
    "PiecewiseDistributionBase.cpp",
    "ProgramOptions.cpp",
    "ProgVersion.cpp",
    "Properties.cpp",
    "RANDOM.cpp",
    "RandomNumberGeneratorFactory.cpp",
    "RapidJsonImpl.cpp",
    "Serializer.cpp",
    "Sigmoid.cpp",
    "StatusReporter.cpp",
    "stdafx.cpp",
    "suids.cpp",
    "Types.cpp",
    "Timers.cpp",
]

utilsLib = env.StaticLibrary('utils', utilsSrcFiles)
